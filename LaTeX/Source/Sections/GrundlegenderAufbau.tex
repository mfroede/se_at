% ---------------------------------------------
% ZielArchitektur
% ---------------------------------------------
\section{Ziel-Architektur}\label{AufBZielArchitektur}
Die für die Generierung vorgesehene Architektur basiert auf 
Architekturkonzepten verschiedener Entwickler und entstand bei der Entwicklung
von vorhergehenden GWT Projekten. Diese Architektur stellte sich dabei als Best
Practice Lösung heraus, welche jedoch aufwändig und fehleranfällig bei der
Umsetzung ist. Dies ist einer der Gründe für dieses Generator Projekt mit OCL.
Im Folgendem wird die umzusetzende Architektur kategorisiert und anhand der zu
erstellenden Klassen und Dateien vorgestellt.
% -------------------Struktur Erklärungen--------------------------
\begin{itemize}
  \item einmalig vorhandene Dateien und Klassen
  \begin{itemize}
    \item \textbf{index.html}\\
    HTML Seite über die durch GWT, die in Java erzeugten View Klassen
    eingebunden werden.
    \item \textbf{styles.css}\\
    CSS Datei für die Festlegung der Style-Eigenschaften.
    \item \textbf{\grqq{}Name\grqq{}.gwt.xml}\\
    Konfigurationsdatei in der u.A. verwendete Bibliotheken sowie
    Browsereinstellungen und der AppEntryPoint eingetragen wird.
    \item \textbf{AppEntryPoint.java}\\
    Bildet die Einstiegsklasse für die GWT Anwendung und erstellt u.A. die
    MainView, die permanenten Views und die HistoryMapper.
    \item \textbf{AbstractView.java}\\
    Die Oberklasse aller View Implementierungen innerhalb einer GWT
    Anwendung. Dadurch wird der Wechsel der Views u.A. der genannten
    MainView über die index.html ermöglicht und Eigenschaften wie die Größe aller
    Views definiert.
    \item \textbf{AbstractActivityDefaultImpl.java}\\
    Diese Klasse wird von allen View Activities erweitert. Sie dient
    mittels einer \textit{start}-Methode dem Aufruf der View Klassen und
    dem Browserzugriff der Views mittels des View \textit{Places}.
    \item \textbf{\grqq{}Name\grqq{}ViewActivityMapperImpl.java}\\
    Instanziiert die \textit{Provider} der Activities (außer die anderer
    ViewActivityMapper), um darüber den View Place, welcher die
    Browseradresse angibt, aufzurufen. Diese Klasse existiert prinzipiell einmal, außer es existieren permanente Views wie ein Header. Je
    permanenter View wird ein weiterer ViewActivityMapper implementiert, welcher
    jeweils einen \textit{Provider} für die eigene Activity instanziiert.
    \item \textbf{AppPlaceHistoryMapper.java}\\
    Dient dem History Management, damit der Zugriff auf die View
    Implementierungen im Browser über den Place stattfinden und eine
    back-Funktionalität implementiert werden kann.
    \item \textbf{AppGinjector.java}\\
    Die Schnittstelle zum Zugriff u.A. auf die
    ViewActivityMapper sowie dem EventBus. Der EventBus dient
    wie der \textbf{AppPlaceHistoryMapper.java} dem History Management und wird
    u.A. zur Registrierung der Start View benötigt.
    \item \textbf{PlaceControllerProvider.java}\\
    Die Schnittstelle zu den View Places, welche in
    den ViewActivityMappern aufgerufen werden und dadurch den Browserzugriff 
    auf die View Implementierungen ermöglichen.
    \item \textbf{ProductionGinModule.java}\\
    In dieser Klasse werden die für GIN typischen bind-Befehle definiert. Diese
    dienen u.A. dazu die View Interfaces an die View Implementierungen zu
    binden sowie die Start View festzulegen.
  \end{itemize}  
  \item View Klassen und Dateien, welche für jede View implementiert werden,
  basierend auf dem MVP-Pattern und den UiBindern
    \begin{itemize}
    \item \textbf{\grqq{}Name\grqq{}Activity.java}\\
    Diese Klasse implementiert den Presenter. Darüber hinaus werden die View
    sowie der PlaceController definiert. Durch den PlaceController wird z.B. die
    Navigation zwischen den Views ermöglicht mittels einer \textit{goTo}-Methode.
    \item \textbf{\grqq{}Name\grqq{}Place.java}\\
    Diese Implementierungen sehen prinzipiell immer gleich aus. Unterschieden
    wird hierbei die dazugehörige View. Über den Place wird die
    Navigation zwischen den Views ermöglicht, wobei der Name des Places in der
    URI Zeile des Browsers steht.
    \item \textbf{\grqq{}Name\grqq{}View.java}\\
    Hierbei handelt es sich um ein Interface, welches das Presenter Interface
    beinhaltet und die Oberklasse für die jeweiligen View Implementierungen ist.
    Dadurch wird der einfache View Austausch durch MVP ermöglicht, welches
    zusätzlich über einen \textit{bind}-Befehl innerhalb des \textit{ProductionGinModule} festgelegt
    werden muss.
    \item \textbf{\grqq{}Name\grqq{}ViewImpl.java}\\
    Die View Implementierung, welche im Browser sichtbar ist. Sie
    implementiert die jeweilige View und beinhaltet eine Instanz des durch
    View und Activity definierten Presenters, wodurch die Kontrolle gemäß MVP
    abgegeben wird. Die Klasse kann entweder das gesamte GUI erstellen oder
    mittels UiBinder einen Teil der View Komponenten abgeben z.B. im Fall von
    vordefinierten Labels.
    \item \textbf{\grqq{}Name\grqq{}ViewImpl.ui.xml}\\
    Innherhalb dieser Datei können Style-Eigenschaften für View Komponenten
    sowie View-Komponenten definiert werden.
  \end{itemize} 
  \item View Klassen und Elemente die auf jeder Ansicht zu sehen sind:
    \begin{itemize}
    \item werden gemäß dem MVP Pattern und wie eine View erstellt.
    \item innerhalb des AppEntryPoint enthalten und definiert.
    \item implementieren jeweils einen eigenen
    \textit{ViewActivityMapper}.
  \end{itemize} 
\end{itemize}
% -------------------View Eintragungen--------------------------
Unter Betrachtung, dass ausschließlich eine View Implementierung existiert
und basierend auf dieser Architektur muss zur Erzeugung einer View:\\
\begin{tabular}{ll} 
\addlinespace
ein Eintrag dazu in den &  \quad \quad folgende Klassen und\\
\underline{folgenden Klassen geschehen} & \quad \quad \underline{Dateien erzeugt
werden}
\\
\addlinespace
\addlinespace
  - \grqq{}Name\grqq{}ActivityMapperImpl.java & \quad \quad - \grqq{}Name\grqq{}Activity.java\\
  - AppPlaceHistoryMapper.java & \quad \quad - \grqq{}Name\grqq{}Place.java\\
  - ProductionGinModule.java & \quad \quad - \grqq{}Name\grqq{}View.java\\
    	& \quad \quad - \grqq{}Name\grqq{}ViewImpl.java\\
    	& \quad \quad - \grqq{}Name\grqq{}ViewImpl.ui.xml\\
\end{tabular}\\
Existieren zu einer View mehrere View Implementierungen so müssen mehrere
Eintragungen innerhalb des \textit{ProductionGinModule} getätigt werden und
mehrere \textit{\grqq{}Name\grqq{}ViewImpl.java} und
\textit{\grqq{}Name\grqq{}ViewImpl.ui.xml} erstellt werden. Dadurch wird eine
gute Abstraktion und lose Kopplung geschaffen. Dies ist jedoch sehr
aufwändig und fehleranfällig, da leicht ein Eintrag vergessen werden kann und
viele Klassen erzeugt werden müssen.

% -------------------Packages--------------------------
Zu den genannten Architekturvorstellungen gehört zusätzlich eine Paketierung,
die auch durch vorherige GWT-Projekte entstand. Der Vorteil der folgenden
Gliederung der Pakete besteht darin, dass innerhalb der
\textit{\grqq{}Name\grqq{}.gwt.xml} Konfigurationsdatei das source-Tag, welches
den Pfad für den zu übersetzenden Java Code angibt, wie folgt: $<source
path='client'/>$ definiert werden kann. Folgend die Gliederung der Klassen und
Dateien innerhalb ihrer Packages:\\\\
\begin{tabular}{ll} 
Package &  \quad \quad Klassen und Dateien\\
\addlinespace
\hline
\addlinespace
  \grqq{}projektname\grqq{} & \quad \quad \grqq{}Name\grqq{}.gwt.xml\\
  \addlinespace
  \hline
  \addlinespace
  \grqq{}projektname\grqq{}.client & \quad \quad AppEntryPoint.java\\
  \addlinespace
  \hline
  \addlinespace
  \grqq{}projektname\grqq{}.client.common & \quad \quad AbstractView.java\\
    	& \quad \quad AbstractActivityDefaultImpl.java\\
    	& \quad \quad \grqq{}Name\grqq{}ViewActivityMapperImpl.java\\
    	& \quad \quad AppPlaceHistoryMapper.java\\
   \addlinespace
   \hline
   \addlinespace
  \grqq{}projektname\grqq{}.client.gin & \quad \quad AppGinjector.java\\
      	& \quad \quad PlaceControllerProvider.java\\
    	& \quad \quad ProductionGinModule.java\\
  \addlinespace
  \hline
  \addlinespace
  \grqq{}projektname\grqq{}.client.view & \quad \quad \grqq{}Name\grqq{}Activity.java\\
  		& \quad \quad \grqq{}Name\grqq{}Place.java\\
    	& \quad \quad \grqq{}Name\grqq{}View.java\\
    	& \quad \quad \grqq{}Name\grqq{}ViewImpl.java\\
    	& \quad \quad \grqq{}Name\grqq{}ViewImpl.ui.xml\\
\end{tabular}\\\\
Jedoch soll für einen Entwickler die Möglichkeit bleiben innerhalb des view
Packages, die Views in Packages zu gliedern. Aus diesem Grund soll an dieser
Stelle das view Package nicht Generator-seitig tiefer gegliedert werden.

Anhand der beschrieben Architektur wird ersichtlich, dass die Erstellung eines
GWT Projektes hauptsächlich im Bereich der einmalig vorhanden Dateien und
Klassen und die Erstellung einer View im groben immer gleich ist. Dies bietet
zwar den Vorteil der Vereinheitlichung mehrerer GWT Projekte und gewährleistet
eine gewisse Übersichtlichkeit und kurze Einarbeitungszeit in verschiedenen GWT
Projekten, ist aber sehr aufwändig und fehleranfällig. Beispielsweise kann über
\grqq{}Copy-Paste\grqq{} viel erstellt und implementiert werden, jedoch ist
dabei das Risiko erhöht, dass Einträge vergessen werden abzuändern oder
hinzuzufügen. Darüber hinaus kann es passieren, das Einträge enthalten sind wie
z.B. einer Bibliothek, welche jedoch nicht mehr benötigt werden und somit nicht
im Build-Path enthalten sind.
Diese Beispiele führen potenziell alle dazu, dass die gesamte GWT Anwendung nicht mehr startet
und die Suche nach dem Fehler erschwert wird, da oftmals viele dieser
Fehler flüchtig geschehen können. 
% ---------------------------------------------
% Profil
% ---------------------------------------------
\section{UML-Profil}\label{AufBProfil}
Eines der Hauptziele ist wie erwähnt die erleichterte Erstellung von GWT
Projekten unter Einbezug der durch die Architektur gegebenen Vorteile. Zu
welchen auch der einfache Austausch von View Implementierungen unabhängig vom Model
gehört. Des Weiteren sollen der Aufwand und die Fehleranfälligkeit bei der
Erstellung eines GWT Projektes sowie zur Erstellung von Views (vgl.
Abschnitt \ref{AufBZielArchitektur}) minimiert werden. Diese Ziele
erfordern einen hohen Abstraktionsgrad innerhalb des Profils sowie weiterhin des
M1-Modells.

Deswegen soll eine der ersten Überlegungen dazu führen, dass das
gesamte GWT Projekt auf ein gemeinsames Element reduziert werden soll. Dieses
Element erscheint im Rahmen des umzusetzenden
MVP-Patterns innerhalb der View Klassen und Dateien
\textit{Activity.java}, \textit{Place.java},
\textit{View.java}, \textit{ViewImpl.java}
und \textit{ViewImpl.ui.xml}. Jedoch erschien dadurch der Aufwand bei der
Erstellung von Views nicht minimiert, da durch diese Stereotypenbildung, diese
im M1-Modell weiterhin Einsatz finden müssen. Aus diesem Grund ist eine weitere
Suche nach dem gemeinsamen Element erforderlich. Dies führt, durch die sich
auch in diesem Bereich als vorteilhaft herausstellende Architektur, dazu, dass
dieses das unterste Element, die \textbf{View Implementierung}, ist. Sie
erscheint ausreichend für die Erstellung der gesamten einmalig vorhandenen Klassen und
Dateien sowie der View Klassen und Dateien, da innerhalb der View
Implementierung und der simultanen und vereinheitlichten Namensbennenung alle
notwendigen Teile generierbar wären. 

Eine weitere Anforderung ist der Austausch der View Implementierungen durch den
Einsatz von MVP. Dieser kann jedoch nicht ausschließlich durch die View
Implementierungen erfolgen, da hierbei eine Möglichkeit zu der
Verbindung mehrerer View Implementierungen gegeben werden muss. Aus diesem Grund
soll das \textbf{View Interfaces} genutzt werden. Dies stellt die Verbindung von mehreren
View Implementierungen in Form einer Oberklasse her. Zusätzlich bietet dies die
Möglichkeit bestimmte Methoden zu definieren, welche für jede implementierende
View nützlich ist. 

View Implementierungen haben zusätzlich View Komponenten und darüber hinaus ist
die Umsetzung einer Navigation bzw. das Verhalten bei Interaktion mit
View Komponenten ein weiteres umzusetzendes Ziel. In vorhergehenden Generator
Projekten ging die Umsetzung dessen mittels Enumerations hervor. Diese sind
sinnvoll wenn eine View Komponente mehrere Attribute z.B. eine Value haben
und kein konkreter Nachbau von bestehenden Frameworks erfolgen soll. In dem Profil
wird ein hoher Abstraktionsgrad erwartet, damit eine Vereinfachung gewährleistet
werden kann. Deswegen bildet der Einsatz von Enumerations als Typ für
View Komponenten einen Mehrwert für die Umsetzung des Profils. Zusätzlich wird ein Layouting als
Ziel ausgeschlossen, wodurch die Nachteile der Verwendung von Enumerations
verringert werden. Dadurch ergibt sich zusätzlich der Einsatz von \textbf{View
Komponenten} als Stereotypen mit dem Attribut \textit{type} vom Typ
\textbf{Enumeration View Objekt Typ}.

Für Navigationselemente wie Buttons und Umsetzung der Navigation ist eine
Überlegung ein weiteres Profil für ActivityDiagramme und somit ein
ActivityDiagramm als M1 Modell zu nutzen. Dieses Mittel ermöglicht eine
Übersicht über die Navigationsstruktur bzw. Verhaltensstruktur einer Anwendung
und ist somit gut geeignet. Dennoch ist das Ziel der Vereinfachung nicht
gegeben, da für jedes Navigationselement ein extra Eintrag in einem
ActivityDiagramm erfolgen muss. Somit entsteht eine Redundanz innerhalb der
verschiedenen M1-Modelle und der Mehrwert der Navigationsgenerierung wird
gemindert aufgrund des Mehraufwandes. Die Verwendung von Enumerations für View
Objekte ermöglichte die Idee, dass für navigierbare bzw. verhaltensbasierte Elemente
eine ähnliche Handhabung dienlich sein kann. Diese ermöglichen die Erfüllung der
Zielsetzung und bieten über die Angabe eines Attributes \textit{goTo} die
Navigation sowie über weiterer Attribute z.B. \textit{openPopup} eine
Generierung verhaltensbezogener Inhalte über das M1-Modell. Dies führt zu der
Stereotypenbildung der \textbf{Navigations View Komponenten} mit
\textbf{Enumeration Navigations View Objekt Typen}. Diese Enumeration enthält
dann z.B. Tree, Button oder MenuBar, d.h. View Komponenten von GWT, welche für
Navigation oder Verhaltensspezifikationen vorgesehen sein sollen.

\textbf{Navigations View Komponente} und \textbf{View Komponenten} sollen 
Properties sein, da eine View Implementierung diese View Komponenten enthalten
kann.

Zur Kopplung von großen Views und zur Erweiterung der vorgegebenen Mittel anhand
der Architektur soll eine weitere Klasse als Stereotyp dienen, die
\textbf{eigenen View Komponenten}. Darin sollen bestehende View Komponenten
enthalten sein und somit eine eigene View Komponente, z.B. eine große
Datentabelle, bilden, die innerhalb mehrerer View Implementierung enthalten sein
kann.

Im Bereich von Views, z.B. ein Header, die auf allen Views innerhalb des
Browsers sichtbar sind, soll eine weitere Stereotypenbildung stattfinden. Diese Views
sind \textbf{permanente Views} und sollen sich zusätzlich in \textbf{Header} und
\textbf{Footer} gliedern, da diese konkrete permanente Views sind durch
ihre Positionierung in einer View (Header oben, Footer unten). Diese Views
verhalten sich simultan zu den normalen Views (vgl. Abschnitt \ref{AufBZielArchitektur}),
weshalb die permanenten Views als View Implementierung von dem View Interface umgesetzt werden können.
Dadurch wird zusätzlich der Austausch von View Implementierungen ermöglicht.
% ---------------------------------------------
% M1-Modell
% ---------------------------------------------
\section{M1-Modell}\label{AufBM1}
Basierend auf dem UML-Profil soll das Modell View Implementierungen enthalten,
welche wiederum View Komponenten als Properties beinhalten und eigene
View Objekte zu diesen View Komponenten zugeordnet sein können. Darüber hinaus
sollen über Attribute innerhalb von dem Stereotyp Navigations View Komponenten,
im M1-Modell enthaltene View Implementierungen angegeben werden. Somit kann z.B. über das Attribut goTo
die Navigation zu dieser View Implementierung durch die Generierung
dessen erfolgen.
Weiterhin sollen permanente View Implementierungen in Form z.B. eines
Headers erstellt werden, welche dann auf jeder View innerhalb des Browsers
sichtbar sind. Eine Implementierung eines Headers soll eine MenuBar enthalten,
die durch MenuItems die Navigation zu verschiedenen Seiten ermöglicht.
Zusätzlich sollen View Interfaces, welche verschiedene
Implementierungen haben, erstellt werden, damit eine Auslegung der
angezeigten Views in der GWT Anwendung für verschiedene Plattformen auf
verschiedenen Devices getestet werden kann. Diese Plattformen können z.B.
ein Browser auf einen Desktop und ein Browser auf einem mobilem Endgerät sein.
Dieser Anwendungsfall würde zusätzlich das Generator Projekt auf höchste Ebene 
prüfen.
% ---------------------------------------------
% Generator
% ---------------------------------------------
\section{Generator}\label{AufBGenerator}
Im Bereich des UML-Profils sowie des M1-Modells sind außer der Views und ihren
Implementierungen und ihren View Komponenten die weiteren Klassen und Dateien
ungeachtet geblieben. Aus diesem Grund muss der Generator so geschrieben werden,
sodass aus dem M1-Modell ein gesamtes GWT Projekt generiert werden kann. Dies
soll potenziell auch ermöglicht werden in dem ausschließlich eine View
Implementierung erstellt wird, welche ohne Attribute und Methoden ausgestattet ist. Dazu soll
eine Unterleitung erfolgen, welche einerseits die einmalig vorhandenen Klassen
mit Inhalten (auch View abhängiger Inhalte) generiert und andererseits die Views
generiert. In dem Fall, dass View Interfaces existieren, sollen die Klassen
\textit{\grqq{}Interfacename\grqq{}View.java}, \textit{\grqq{}Interfacename\grqq{}Activity.java} und
\textit{\grqq{}Interfacename\grqq{}Place.java} den Interfacenamen tragen. Die
Implementierungsklassen bzw. Dateien \textit{\grqq{}Klassenname\grqq{}ViewImpl.java} und
\textit{\grqq{}Klassenname\grqq{}ViewImpl.ui.xml} der View, haben die
Implementierungsklassennamen. Darüber hinaus sollen die viewabhängigen Inhalte,
wenn mehr als eine View Implementierung vorhanden ist, mittels eines boolean
\textit{binding} dementsprechend unterschieden werden. Dadurch sollen alle
Inhalte basierend auf View Implementierungen mit dem
\textit{binding} gleich false auskommentiert werden.
Dadurch kann ein einfacher Austausch bei einem Wechsel der View über das
MVP-Pattern ermöglicht werden, ohne Code hinzufügen zu müssen.
In dem Fall, dass kein View Interface zu einer Implementierung gehört, so werden
alle Klassen, Dateien und View abhängigen Inhalte mittels des
Implementierungsklassennamens generiert.

Für alle permanenten Views gilt ein
ähnliches Vorgehen wie bei den normalen Views. Jedoch haben diese die
Besonderheit, dass sie in jeder View zu sehen sind und somit zusätzlich zu der
\textit{MainView} in dem \textit{AppEntryPoint.java} eingetragen
werden müssen. Dazu erfolgt eine durch das Profil vorgegebene Unterscheidung
zwischen normalen permanenten Views und Header und Footer. Da Header (oben) und Footer
(unten) eine feste Positionierung auf einer Webseite haben, sollen diese durch
den Generator dementsprechend in dem \textit{AppEntryPoint.java} positioniert
werden.
Alle anderen vorhandenen permanenten Views sollen dazwischen eingetragen werden
und müssen später durch den Entwickler positioniert werden, da dies
layoutspezifisch ist.

Der Entwickler soll weiterhin zusätzliche Änderungen vornehmen müssen. Diese
betreffen die Startseite der GWT Webanwendung, welche in dem generiertem
Code anstatt einer konkreten Angabe des Klassennamens, innerhalb des Befehls,
über \grqq{}Start\grqq{} gekennzeichnet wird. Dieses Vorgehen kann das Verständnis
für die Architektur stärken und es werden überflüssige und überfüllende
Attribute innerhalb des Profils und M1-Modells vermieden.

Darüber hinaus soll der Generator auch strukturelle und redundanzfreie
Anforderungen erfüllen. Dazu sollen Util Generatoren für u.A.
Package Declarations, Constants und abfragebedingter Query-Blöcke, welche
mehrfach Verwendung finden, geschrieben werden. Zusätzlich sollen weitere
Trennungen erfolgen innerhalb der generierbaren Teile. Zu diesen gehören die
Generierung der View Interfaces und die Generierung der konkreten View Implementierungen. Wobei
hierbei nochmals anzumerken ist, dass die Interface Generierung für die View
Implementierungen auf die Generierung der konkreten View Implementierungen
zugreift. Eine weitere Trennung soll innerhalb der einmalig vorhandenen Klassen
und Dateien erfolgen, da manche Klassen und Dateien nicht View abhängige Inhalte
haben.

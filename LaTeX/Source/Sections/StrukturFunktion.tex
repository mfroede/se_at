\section{Struktur} \label{StrukturFunktion}
Der Generator ist so konzipiert, dass er mit Hilfe des kleinsten gemeinsamen Elements, der \texttt{ViewImpl}, alle GWT relevanten Klassen erzeugen kann. Daher ist es auch möglich mit nur einer einzigen Klasse vom Stereotype \texttt{ViewImpl} eine gesamte GWT Anwendung zu generieren.
Der Hauptgenerator bzw. das Haupttemplate im MTL \texttt{generate.mtl} ist die Einstiegsstelle zum Verarbeiten, wenn eine Klasse aus dem UML Modell gelesen wird. In diesem Template werden folgenden Templates aufgerufen, die die Struktur für GWT und damit auch die des Generators sicherstellen: \\

\begin{center} 
    \begin{tabular}{   p{0.25\textwidth}   p{0.25\textwidth}  p{0.35\textwidth} } 
  
    \textbf{MTL} & \textbf{Zuständigkeit} & \textbf{Beispiele}\\ \hline
\hline
   \texttt{generate"-Basic"-Static"-Structure.mtl}   &  Generierung aller einmaligen Klassen, die unabhängig vom M1 Modell sind  &   Erstellung der .gwt.xml, der index.html oder der style.css\\ \hline

    \texttt{generate"-Structure.mtl} & Generierung der einmalig vorhandenen Klassen, welche inhaltlich abhängig von dem Modell bzw. der Views sind.& AppGinjector.java, App"-Entry"-Point.java oder Production"-Gin"-Module.java\\ \hline

\texttt{generateMVP.mtl} &  Stellt die Generierung aller MVP spezifischen Objekte sicher. & wie Activity, Place, View, ViewImpl und ui.xml \\ \hline

\texttt{generate"-Own"-View"-Object.mtl} &  Template, welches sich um die gesonderte Generierung des OwnViewObject kümmert. & Generierung einer OwnViewObject Java-Klasse mit im M1 Modell festgelegten Widget-Attributen und Operationen \\\hline

    \end{tabular}
\end{center}

Die oben erwähnten Generatoren bedienen sich mehrerer Hilfsgeneratoren, darunter eine \texttt{util.mtl}, die beispielsweise die ganzen Queries zusammenfasst oder auch Template-Aufrufe für die Protected Regions bereitstellt. Zudem existiert eine \texttt{packageDeclaration.mtl} die sich darum kümmert, dass für Klassen oder Interfaces die richtigen Namen entsprechend ihrer Paketierung zurückgeben werden. 

\section{Funktion}\label{Funktion}
Um die Struktur des Generators zu verdeutlichen, wird folgend auf die wichtigsten Funktionen ausführlicher eingegangen.

Eines dieser wichtigen Elemente stellt die Klasse des \texttt{AppEntryPoint}s dar. Denn diese beschreibt die Zugriffsklasse für GWT und es werden von dieser gleichzeitig die ersten UI-Panel gesetzt. Hierbei ist im Generator zwischen einer \textit{PermanentView} und einer \textit{ContentView} zu unterscheiden. Es können durchaus mehrere \textit{PermanentViews} vorhanden sein. Der Contentbereich ist dagegen immer nur einmal vorhanden und dient so als Container für alle\textit{ViewImpls}. So müssen alle \textit{PermanentViews} mittels \texttt{for}-Schleife durchlaufen werden. Zudem sind die Spezialfälle der \textit{PermanentView}, \textit{Footer} und \textit{Header}, auch unterschiedlich zu behandeln, da diese eine feste Positionierung besitzen. Alle anderen Layout-spezifischen Entscheidungen müssen vom späteren Entwickler gesetzt werden. Sämtliche \textit{PermanentViews} und der Content werden dann als SimplePanel zu dem GWT \texttt{RootPanel} hinzugefügt (Listing \ref{BSPCodeRoot}). \\
\lstset{language=OCL}\label{BSPCodeRoot}
\begin{lstlisting}[caption={Hinzufügen eines Panels zum RootPanel, am Beipsiel eines Header}]
[for (class : Class | pack.ownedElement)]
	[if ( class.getAppliedStereotypes()->asOrderedSet()->first().name.endsWith('Header') )]
		RootPanel.get().add( [getClassName(class).toLowerFirst()/] );
	[/if]
[/for]
\end{lstlisting}
Ein weiteres wichtiges Element ist der von GIN stammende \texttt{bind}-Befehl, der sicherstellt, das GWT automatisch weiß welches Interface zu welcher Implementierung instanziiert wird.
Damit der \texttt{bind}-Befehl in der \texttt{ProductionGinModule}-Klasse, richtig gesetzt wird, muss mittels Generator aus dem M1 Modell das \texttt{concreteBinding} Attribut einer \textit{ViewImpl}- Klasse ausgelesen und entsprechend seines Wertes behandelt werden. Wenn die \texttt{concreteBinding} Variable den Wert true hat, wird das View Interface an die entsprechende View Implementierung gebunden. Sollte der Wert auf false gesetzt sein, so wird dieser \texttt{bind-Befehl} trotzdem ausgeführt, allerdings in kommentierter Form. So ist es später möglich bei Wechsel einer View, den entsprechenden \texttt{bind}-Befehl auszutauschen, ohne neuen Code schreiben zu müssen. Die Generierung dieses Befehls ist im Listing \ref{BSPCodeBind} zu sehen.
Zudem werden im Generator bewusst Fehler erzeugt, die dem Entwickler später darauf hinweisen sollen, an welchen Klassen noch von Hand Änderungen vorzunehmen sind. So passiert dies beispielsweise immer dann, wenn in einer Klasse ein ‚YourStartHere‘ steht. Hier ist der Entwickler gezwungen, den Namen seiner Startseite einzutragen. Dies geschieht auch bei den \texttt{bind-Befehlen}, bei denen es wichtig ist, dass zuerst die Startseite das binding erhält und anschließend den anderen View Interfaces ihr jeweiliges binding an deren Implementierung zugewiesen wird.
\lstset{language=OCL}
\begin{lstlisting}[caption={Auszug aus der Generierung des bind-Befehls}, label={BSPCodeBind}]
bind(YourStartHereActivity.class);   
[for (class : Class | pack.ownedElement)]
	[if (not isNotViewExisting(class))]
		[for (p : Property | class.getAppliedStereotypes()->asOrderedSet()->first().attribute)]
		[if (p.name.endsWith('concreteBinding'))]
			[if(not class.getValue(class.getAppliedStereotypes()->asOrderedSet()->first(),p.name).oclAsType(Boolean))]
		// bind([getClassName(class)/]View.class).to([class.name/]ViewImpl.class).in(Singleton.class);
			[else]
		bind([getClassName(class)/]View.class).to([class.name/]ViewImpl.class).in(Singleton.class);
			[/if]
		[/if]
		[/for]
	[else]
		bind([getClassName(class)/]View.class).to([class.name/]ViewImpl.class).in(Singleton.class);
	[/if]	
[/for]
\end{lstlisting}

Als weitere Funktion wird im Folgenden die Generator-seitige Umsetzung des MVP Patterns beschreiben. Dieser wurde nach zwei Templates getrennt. Zum einen werden die View Interfaces mit entsprechenden Place und Activity Klassen und zum anderen die View Implementierungen mit dazugehörigen \texttt{ui.xml} Dateien generiert.
Jedes View Interface besitzt ein Interface Presenter und die entsprechende \texttt{setPresenter()}-Methode sowie andere Operationen, soweit im M1 Modell festgehalten. Zusätzlich enthält das Interface für jedes Navigations Objekt eine \texttt{on'Name'Clicked()}-Methode, zu sehen im Listing \ref{BSPCodeClick}. Auch hier wird zusätzlich wie bei dem \texttt{bind}-Befehl die gleiche Methode als Kommentar geschrieben, sofern deren \texttt{concreteBinding}-Attribute auf false gesetzt ist (siehe Listing \ref{BSPCodeClick}). Ein Sonderfall bietet der Button, deren \texttt{onButtonClicked()}-Methode nur einmal generiert wird, unabhängig davon wie viele Buttons existieren. Denn die Buttons werden während der Implementierung mit Hilfe von\texttt{ if}-Bedingungen innerhalb dieser Methode voneinander unterschieden und entsprechend behandelt. Es wurde sich bewusst für die etwas unschöne Art der Programmierung mittels \texttt{label}-Abfrage des Buttons in der\texttt{if}-Bedingung entschieden, da nicht davon ausgegangen wird, dass mehr als fünf Buttons sinnvoller Weise auf einer Webseite angebracht werden sollten.Wenn dies doch mal Eintritt beispielsweise durch eine Datentabelle, würde diese eh vom Entwickler implementiert und nicht im M1 Modell festgelegt werden.
In der Activity Klasse wird der Presenter implementiert und über die \texttt{goto}-Methode des texttt{PlaceController}s die Navigation zwischen den Webseiten geschaffen. Durch die Implementierung der View Methoden, muss vor jeder \texttt{on'Name'Clicked()}-Methode die \texttt{@Override}-Annotation hinzugefügt werden. Diese dient dann als Wrapper Methode für die eigentliche \texttt{goto}-Methode.
\lstset{language=OCL}
\begin{lstlisting}[caption={Auszug der Generieung der on'Name'Clicked() Methode}, label={BSPCodeClick}]
[for (class: Class | interface.getTargetDirectedRelationships().source.oclAsType(Class))]
		[for (property: Property | class.attribute)]
			[if (property.getAppliedStereotypes()->asOrderedSet()->first().name.endsWith('NavigationObject'))]
				[if (not getValue(property.getAppliedStereotypes()->asOrderedSet()->first(), 'type').oclAsType(uml::EnumerationLiteral).name.endsWith('BUTTON'))]
					[if (class.getValue(class.getAppliedStereotypes()->asOrderedSet()->first(), 'concreteBinding').oclAsType(Boolean))]						
		@Override
		void on[property.name.toUpperFirst()/]Clicked(){
			placeController.gotTo(new [getClassName(property.getTaggedValue(property.getApplicableStereotypes()->asOrderedSet()->first().name, 'goToView', true)->asOrderedSet()->first().oclAsType(uml::Class))/]Place());
		}
					[else]
		// @Override
		// void on[property.name.toUpperFirst()/]Clicked(){
		//	placeController.gotTo(new [getClassName(property.getTaggedValue(property.getApplicableStereotypes()->asOrderedSet()->first().name, 'goToView', true)->asOrderedSet()->first().oclAsType(uml::Class))/]Place());
		// }
					[/if]
				[/if]
			[/if]
		[/for]
	[/for]
\end{lstlisting}

Sollte zu einer View Implementierung kein View Interface vorhanden sein, wird View, Activity und Place anhand der Implementierung ähnlich zu dem Interface generiert.
In der konkreten ViewImpl geschieht mittles @UIField das 'Binding' von ViewObject oder ViewNavigationObject an die \texttt{ui.xml}. Zur Vereinfachung der zu generierdenden xml Elemente wurde beispielsweise für eine Liste oder eine Tabelle das GWT UI Element texttt{grid} verwendet. Darüber hinaus bietet dieses mehr Möglichkeiten verschiedenste Elemente, wie Buttons oder Textfelder einzubinden. Des Weiteren ist noch zu beachten, dass wenn ein Tree oder Menu mit Navigationselementen vorhanden ist, für jedes innere Element ein TreeItem oder MenuItem erzeugt werden muss. So ist sichergestellt, dass die Struktur der Widgets erhalten bleibt und entsprechend ihre GWT Deklarationen funktionieren.
Darüber hinaus werden für alle UI Elemente die texttt{ui.xml} zur entsprechenden \textit{ViewImpl} in einem separaten \texttt{viewXML}-Template generiert. Hierfür wurde für jedes UI Element ein eigenes Template geschrieben, das dann in der \texttt{viewXML} aufgerufen wird. Als Beipiel für die Generieung  eines UI Elementes ist im Listing \ref{BSPCodeMenu} ein Menu zu sehen.
\lstset{language=OCL}
\begin{lstlisting}[caption={Template für die XML - Generierung eines Menus}, label={BSPCodeMenu}]
[template public newMenu (property : Property) ]
[if (isValueExists(property, 'type', 'MENU'))]
<g:MenuBar ui:field="[property.name/]">
[if(property.getValue(property.getAppliedStereotypes()->asOrderedSet()->first(), 'viewNavigationObject')->notEmpty())]
	[for (prop : Property | property.getTaggedValue('ViewObject','viewNavigationObject', false).oclAsSet().oclAsType(Property))]
	<g:MenuItem ui:field="[prop.name/]" text="[prop.getValue(prop.getAppliedStereotypes()->asOrderedSet()->first(), 'value')/]"/>
	[/for]
[/if]
</g:MenuBar>
[/if]
[/template]
\end{lstlisting}
Abschließend ist zum \texttt{OwnViewObject} zu sagen, dass dieses durch Vererbung der GWT - Widget Klasse als eigenständiges Widget erzeugt wird. Das \texttt{OwnViewObject} besitzt keinen eigenen Konstruktor, da keine Kenntnis von deren Inhalt bekannt ist. Denn das Aussehen dieser Klasse wird komplett dem Entwickler überlassen und steht zum Zeitpunkt der Generierung noch nicht fest. Dies hat zur Folge, dass die Generierung dieser Klasse weitestgehend als eine normale Klasse behandelt wird, die schon aus dem M1 Modell vorhandene UI Elemente als eigene Attribute und Operationen generiert. 
